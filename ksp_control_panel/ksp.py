import serial
import krpc

# initialize connection to krpc, serial connection to arduino and krpc vessel
conn = None
ser = None
vessel = None

throttlemin = 35
throttlemax = 1010

try:
    # Ccm4 is USB connection type/name and 38400 is "baud rate"
    ser = serial.Serial('COM4', 38400)
except serial.SerialException:
    print("Is your usb cable connected?")

i = 0

try:
    conn = krpc.connect()
except ConnectionRefusedError:
    print("Is kerbal running?")
if conn is not None:
    vessel = conn.space_center.active_vessel

sas = False


# takes input as string
# returns true if input is "good" per protocol
def checkinput(i):
    for c in i:
        c = ord(c)
        if c >= 48 and c <= 57:  # allow numbers
            continue

        elif c == 33 or c == 46:  # allow ! and .
            continue
        else:
            print("x" * 10)
            print("GO CHECK THIS", i)
            print("x" * 10)
            return False
    return True


# accept an integer throttle input between 35 and 1000 and create a return such that 0<=ret<=1
def throttlecontrol(throttleinput):
    # set the return function to the equation of the line between min and max
    # we use the equation generated by wolfram alpha
    ret = round((throttleinput - throttlemin) / (throttlemax - throttlemin), 3)
    if ret < 0.1:
        return 0.0
    return ret


# take a str,int, bool or float and craft a <=12 character byte array encoded with latin-1
# truncates if input is too long.
# returns the number of bytes sent
def output(out):
    size = 12
    if type(out) == str:
        pass
    if type(out) == int:
        out = str(out)[:size]
    elif type(out) == bool:
        if out:
            out = 1
        else:
            out = 0
        out = str(out)
    elif type(out) == float:
        out = str(int(round(out, 0)))[:size]
    out = ((size - len(out)) * "0") + out

    return ser.write(out.encode('latin-1'))


# takes an integer value between 1- 1024 and generates a float between -1,1
def fcs(input):
    fc = round((int(input) / 512) - 1, 2)
    return fc


# boolean for testing sync
sync = True

# loop forever
while True:
    if vessel is None:
        break
    # try to get 16 characters this try block is crap
    try:
        i = ser.read(16).decode("latin-1")
    except ValueError as e:
        print(e, i)
    # convert the bytes to a string
    i = str(i)
    if i[3] == "." or i[0] == "!":
        sync = True
    else:
        print("p sync is BAD")
        sync = False

    while sync is not True:
        try:
            i = ser.read(1).decode("latin-1")
        except ValueError as e:
            print(e, i)
        try:
            i = ser.read(16).decode("latin-1")
        except ValueError as e:
            print(e, i)
        i = str(i)
        if input[0] == "!" or input[3] == ".":
            print("p sync is good")
            sync = True

    if i[0] is "!":
        # example string looks like !00234.1000.0001

        # remove the ! and split the data into a list
        data = i[1:].split(".")
        # for example data would now contain [00234,1000,1]
        yaw, pitch, roll = data
        # yaw, pitch and roll take those three values and are converted
        vessel.control.yaw = fcs(yaw)
        # good link to the API
        # https://krpc.github.io/krpc/python/api/space-center/control.html#SpaceCenter.Control.pitch
        vessel.control.pitch = fcs(pitch)
        vessel.control.roll = fcs(roll)
        continue
    elif "500" in i:

        # same premise except the "command" sent is 500. This is throttle control
        # same thought process as above.
        # we floor and max values at the min and max throttles to send allowed by arduino
        # to get the vessel to behave as expected
        data = i.split(".")
        throttle = int(data[1])
        if throttle < throttlemin:
            throttle = throttlemin
        if throttle > throttlemax:
            throttle = throttlemax
        throttle = throttlecontrol(throttle)
        vessel.control.throttle = throttle
        continue
    elif "501" in i:
        # throttle setup used at the beginning of sync with krpc and arduino
        # essentially, read the throttle of the vessel in game
        throttle = vessel.control.throttle
        # this is the reverse of the equation in throttlecontrol()
        out = (throttlemax - throttlemin) * throttle + throttlemin
        out = int(out)
        # floor it, we cannot set the throttle to a float

        output(out)
        continue
    elif "601" in i:
        altitude = vessel.flight().mean_altitude
        # print(altitude)

        output(altitude)
        continue
    elif "602" in i:
        apoapsis = vessel.orbit.apoapsis_altitude
        output(apoapsis)
        continue
    elif "603" in i:
        periapsis = vessel.orbit.periapsis_altitude
        output(periapsis)
        continue
    elif "604" in i:
        orbitspeed = vessel.orbit.speed
        output(orbitspeed)
        continue
    elif "999" in i:
        print("p", i)

    elif "301" in i:  # execute button pressed
        vessel.control.activate_next_stage()
        continue
    elif "302" in i:  # abort button pressed
        vessel.control.abort = True
        continue

    elif "400" in i:
        vessel.control.sas = True
        continue

    elif "401" in i:
        vessel.control.sas_mode = conn.space_center.SASMode.stability_assist
        continue

    elif "402" in i:
        # @TODO ADD CATCH
        try:
            vessel.control.sas_mode = conn.space_center.SASMode.maneuver
        except RuntimeError:
            print("p maneuver not available")
        continue

    elif "403" in i:
        try:
            vessel.control.sas_mode = conn.space_center.SASMode.prograde
        except RuntimeError:
            print("p PROGRADE not available")
        continue

    elif "404" in i:
        try:
            vessel.control.sas_mode = conn.space_center.SASMode.retrograde
        except RuntimeError:
            print("p RETROGRADE not available")
        continue

    elif "405" in i:
        vessel.control.sas_mode = conn.space_center.SASMode.normal
        continue

    elif "406" in i:
        vessel.control.sas_mode = conn.space_center.SASMode.anti_normal
        continue

    elif "407" in i:
        vessel.control.sas_mode = conn.space_center.SASMode.radial
        continue

    elif "408" in i:
        vessel.control.sas_mode = conn.space_center.SASMode.anti_radial
        continue

    elif "409" in i:
        # @TODO ADD CATCH
        try:
            vessel.control.sas_mode = conn.space_center.SASMode.target
        except RuntimeError:
            print("p target not available")
        continue

    elif "410" in i:
        # @TODO ADD CATCH
        try:
            vessel.control.sas_mode = conn.space_center.SASMode.anti_target
        except RuntimeError:
            print("p anti target not available")
        continue

    elif "411" in i:
        vessel.control.sas = False
        continue

# if i == 202:  #reset button pressed
# try-catch method to reset connection to vessel

# engine start/stop switch
# active_engines = [e for e in vessel.parts.engines if e.active and e.has_fuel]
# print('Active engines:')
# for engine in active_engines:
#    print('     %s in stage %d' % (engine.part.title, engine.part.stage))

# engine.part.engine.active = False